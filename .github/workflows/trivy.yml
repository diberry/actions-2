name: Trivy image scans

# Images that can't be scanned:
# Private images (need auth)
# Devcontainer features (aren't real images)

# touch
on:
  workflow_dispatch:
    inputs:
      repoOwner:
        description: 'Repository owner'
        required: true
        type: string
      repoName:
        description: 'Repository name'
        required: true
        type: string
      runId:
        description: 'Unique identifier for the workflow run (for tracking purposes)'
        required: true
        type: string
        default: ''

permissions:
  contents: read
  security-events: write # Required for uploading Trivy scan results to GitHub Security tab
  actions: read # To read workflow run status


jobs:
  find-images:
    name: Find Docker Images
    runs-on: ubuntu-latest
    outputs:
      stop_workflow: ${{ env.stop_workflow }}
      found_count: ${{ steps.count-output.outputs.found }}
      files_found: ${{ steps.count-output.outputs.files_found }}
    steps:
      - name: Debug log file
        run: |
          echo "Contents of trivy.log:"
          cat trivy.log || echo "trivy.log not found"

      - name: Validate inputs
        run: |
          if [ -z "${{ github.event.inputs.repoOwner }}" ]; then
            echo "Error: repoOwner input is required."
            exit 1
          fi
          if [ -z "${{ github.event.inputs.repoName }}" ]; then
            echo "Error: repoName input is required."
            exit 1
          fi
          if [ -z "${{ github.event.inputs.runId }}" ]; then
            echo "Error: runId input is required."
            exit 1
          fi

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          repository: ${{ github.event.inputs.repoOwner }}/${{ github.event.inputs.repoName }}
        continue-on-error: false

      - name: Install required tools
        run: |
          echo "Installing required tools..." >> trivy.log
          sudo apt-get update
          sudo apt-get install -y ripgrep jq
          echo "Required tools installed." >> trivy.log

      - name: Verify Trivy availability (install if missing)
        run: |
          echo "Verifying Trivy availability..." >> trivy.log
          set +e
          # Try to install Trivy; don't fail the job if install fails
          if curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sudo sh -s -- -b /usr/local/bin >> trivy.log 2>&1; then
            echo "trivy install script ran (or trivy already present)" >> trivy.log
          else
            echo "trivy install script failed or network error" >> trivy.log
          fi

          # Check if trivy is available now
          if command -v trivy >/dev/null 2>&1; then
            echo "trivy available: $(trivy --version 2>&1)" >> trivy.log
            echo "stop_workflow=false" >> $GITHUB_ENV
          else
            echo "trivy CLI not available; setting stop_workflow=true to skip scans" >> trivy.log
            echo "stop_workflow=true" >> $GITHUB_ENV
          fi
          set -e

      - name: Remove old files
        run: |
          set -euo pipefail
          echo "Removing old files..." >> trivy.log
          rm -f candidate_files.txt files_with_images.txt tmp_images images.txt devcontainer_images.txt dockerfile_images.txt docker_compose_images.txt generic_images.txt || true
          echo "Old files removed." >> trivy.log


      - name: Init scan log
        run: |
          echo "Trivy scan started: $(date -u)" >> trivy.log
          # log incoming workflow_dispatch inputs individually
          echo "repo_owner=${{ github.event.inputs.repoOwner }}" >> trivy.log
          echo "repo_name=${{ github.event.inputs.repoName }}" >> trivy.log
          echo "repo=${{ github.event.inputs.repoOwner }}/${{ github.event.inputs.repoName }}" >> trivy.log
          echo "run_id=${{ github.event.inputs.runId }}" >> trivy.log


      - name: Find candidate files by filename patterns
        run: |
          echo "Finding candidate files by filename patterns..." >> trivy.log
          find . -type f \( \
            -iname 'Dockerfile*' -o \
            -iname '*docker-compose*.yml' -o \
            -iname '*docker-compose*.yaml' -o \
            -path './.devcontainer/*' -o \
            -iname '*.devcontainer.json' -o \
            -iname '*.bicep' -o \
            -iname '*.tf' -o \
            -iname '*.yaml' -o \
            -iname '*.yml' \
          \) -not -path './.git/*' -print > candidate_files.txt || true
          echo "Candidate file search completed." >> trivy.log

      - name: Log candidate files
        run: |
          echo "Logging candidate files..." >> trivy.log
          echo "candidate_files_count=$(wc -l < candidate_files.txt 2>/dev/null || echo 0)" >> trivy.log
          echo "candidate_files:" >> trivy.log
          if [ -s candidate_files.txt ]; then
            sed 's/^/ - /' candidate_files.txt >> trivy.log
          else
            echo " - (none)" >> trivy.log
          fi
          echo "Candidate files logged." >> trivy.log

      - name: Filter candidate files for image-like content
        run: |
          echo "Filtering candidate files for image-like content..." >> trivy.log
          while IFS= read -r f; do
            # Skip if empty
            [ -z "$f" ] && continue

            echo "Processing file: $f" >> trivy.log

            # Check for common hints: 'image:' key, FROM lines, or any registry-looking token
            if rg -n --hidden --no-ignore-vcs --glob '!.git/**' -e '^\s*image\s*:' -e '^\s*FROM\s+' -e '([a-z0-9.-]+(?::[0-9]+)?/)[A-Za-z0-9._/-]+' "$f" > /dev/null 2>&1; then
              echo "File contains image-like content: $f" >> trivy.log
              echo "$f" >> files_with_images.txt
            else
              echo "No image-like content found in file: $f" >> trivy.log
            fi
          done < candidate_files.txt || true
          echo "Filtering completed." >> trivy.log



      - name: Extract image values from .devcontainer.json files
        run: |
          echo "Extracting image values from .devcontainer.json files..." >> trivy.log
          # Find all .devcontainer.json files
          find . -type f -name 'devcontainer.json' -o -path '**/.devcontainer/devcontainer.json' -not -path './.git/*' > devcontainer_files.txt || true

          # Create a separate file for devcontainer images
          touch devcontainer_images.txt

          # Check if any .devcontainer.json files were found
          if [ -s devcontainer_files.txt ]; then
            echo "Found devcontainer.json files:" >> trivy.log
            cat devcontainer_files.txt >> trivy.log
            while IFS= read -r file; do
              echo "Scanning file: $file" >> trivy.log
              # Extract the "image" value from the JSON file
              # Use a more permissive filter that still excludes non-image values
              jq -r '.image // empty' "$file" | grep -E '^[a-zA-Z0-9][a-zA-Z0-9._-]*(:[0-9]+)?/[a-zA-Z0-9][a-zA-Z0-9._/-]*(:[a-zA-Z0-9._-]+)?$|^[a-zA-Z0-9][a-zA-Z0-9._-]*:[a-zA-Z0-9._-]+$|^[a-zA-Z0-9][a-zA-Z0-9._-]*/[a-zA-Z0-9][a-zA-Z0-9._-]*$' | tee -a devcontainer_images.txt >> tmp_images || true
            done < devcontainer_files.txt
          else
            echo "No devcontainer.json files found." >> trivy.log
          fi

          # Display the images found in devcontainer.json files
          echo "==== Images found in devcontainer.json files ====" | tee -a trivy.log
          if [ -s devcontainer_images.txt ]; then
            cat devcontainer_images.txt | tee -a trivy.log
          else
            echo "No images found in devcontainer.json files." | tee -a trivy.log
          fi
          echo "=================================================" | tee -a trivy.log

          echo "Image extraction from .devcontainer.json files completed." >> trivy.log

      - name: Debug .devcontainer.json parsing
        run: |
          echo "Debugging .devcontainer.json parsing..." >> trivy.log
          while IFS= read -r file; do
            echo "Scanning file: $file" >> trivy.log
            jq -r '.image // empty' "$file" >> trivy.log || echo "jq failed for $file" >> trivy.log
          done < devcontainer_files.txt
          echo "Debugging completed." >> trivy.log


      - name: Extract image values from Dockerfiles
        run: |
          echo "Extracting image values from Dockerfiles..." >> trivy.log
          # Find all Dockerfiles
          find . -type f -iname 'Dockerfile*' -not -path './.git/*' > dockerfile_files.txt || true

          # Create a separate file for Dockerfile images
          touch dockerfile_images.txt

          # Log the found Dockerfiles
          echo "Found Dockerfiles:" >> trivy.log
          if [ -s dockerfile_files.txt ]; then
            cat dockerfile_files.txt >> trivy.log
          else
            echo "No Dockerfiles found." >> trivy.log
          fi

          # Extract "FROM" values with a more permissive filter
          if [ -s dockerfile_files.txt ]; then
            while IFS= read -r file; do
              echo "Scanning file: $file" >> trivy.log
              rg -o '^\s*FROM\s+[^\s]+' "$file" --hidden --no-ignore-vcs 2>/dev/null \
                | sed -E 's/^\s*FROM\s+//' \
                | sed -E 's/\s+AS\s+.*//' \
                | grep -E '^[a-zA-Z0-9][a-zA-Z0-9._-]*(:[0-9]+)?/[a-zA-Z0-9][a-zA-Z0-9._/-]*(:[a-zA-Z0-9._-]+)?$|^[a-zA-Z0-9][a-zA-Z0-9._-]*:[a-zA-Z0-9._-]+$|^[a-zA-Z0-9][a-zA-Z0-9._-]*/[a-zA-Z0-9][a-zA-Z0-9._-]*$' | tee -a dockerfile_images.txt >> tmp_images || true
            done < dockerfile_files.txt
          fi

          # Display the images found in Dockerfiles
          echo "==== Images found in Dockerfiles ====" | tee -a trivy.log
          if [ -s dockerfile_images.txt ]; then
            cat dockerfile_images.txt | tee -a trivy.log
          else
            echo "No images found in Dockerfiles." | tee -a trivy.log
          fi
          echo "====================================" | tee -a trivy.log

          echo "Image extraction from Dockerfiles completed." >> trivy.log

      - name: Debug Dockerfile parsing
        run: |
          echo "Debugging Dockerfile parsing..." >> trivy.log
          while IFS= read -r file; do
            echo "Scanning file: $file" >> trivy.log
            rg -o '^\s*FROM\s+[^\s]+' "$file" --hidden --no-ignore-vcs 2>>trivy.log \
              | sed -E 's/^\s*FROM\s+//' \
              | sed -E 's/\s+AS\s+.*//' >> trivy.log || echo "rg failed for $file" >> trivy.log
          done < dockerfile_files.txt
          echo "Debugging completed." >> trivy.log


      - name: Extract image values from Docker Compose files
        run: |
          echo "Extracting image values from Docker Compose files..." >> trivy.log
          # Find all Docker Compose files
          find . -type f \( -iname '*docker-compose*.yml' -o -iname '*docker-compose*.yaml' \) -not -path './.git/*' > docker_compose_files.txt || true

          # Create a separate file for Docker Compose images
          touch docker_compose_images.txt

          # Log the found Docker Compose files
          echo "Found Docker Compose files:" >> trivy.log
          if [ -s docker_compose_files.txt ]; then
            cat docker_compose_files.txt >> trivy.log
          else
            echo "No Docker Compose files found." >> trivy.log
          fi

          # Extract "image" values and filter for valid Docker image formats
          if [ -s docker_compose_files.txt ]; then
            while IFS= read -r file; do
              echo "Scanning file: $file" >> trivy.log
              # Extract the "image" values from the YAML file
              rg -o '^\s*image:\s*[^\s]+' "$file" --hidden --no-ignore-vcs 2>/dev/null \
                | sed -E 's/^\s*image:\s*//' \
                | grep -E '^[a-zA-Z0-9][a-zA-Z0-9._-]*(:[0-9]+)?/[a-zA-Z0-9][a-zA-Z0-9._/-]*(:[a-zA-Z0-9._-]+)?$|^[a-zA-Z0-9][a-zA-Z0-9._-]*:[a-zA-Z0-9._-]+$|^[a-zA-Z0-9][a-zA-Z0-9._-]*/[a-zA-Z0-9][a-zA-Z0-9._-]*$' | tee -a docker_compose_images.txt >> tmp_images || true
            done < docker_compose_files.txt
          fi

          # Display the images found in Docker Compose files
          echo "==== Images found in Docker Compose files ====" | tee -a trivy.log
          if [ -s docker_compose_images.txt ]; then
            cat docker_compose_images.txt | tee -a trivy.log
          else
            echo "No images found in Docker Compose files." | tee -a trivy.log
          fi
          echo "=============================================" | tee -a trivy.log

          echo "Image extraction from Docker Compose files completed." >> trivy.log

      - name: Extract image tokens from discovered files
        run: |
          echo "Extracting image tokens from discovered files..." >> trivy.log
          
          # Create a separate file for generic image tokens
          touch generic_images.txt
          
          while IFS= read -r f; do
            [ -z "$f" ] && continue
            echo "Scanning file: $f" >> trivy.log
            
            # Extract image references with a more permissive filter
            rg -o '([a-zA-Z0-9][a-zA-Z0-9._-]*(?::[0-9]+)?/)?[a-zA-Z0-9][a-zA-Z0-9._/-]*(?::[a-zA-Z0-9._-]+|@sha256:[a-f0-9]{64})' --hidden --no-ignore-vcs "$f" \
              | grep -v -E '(localhost|127\.0\.0\.1)' \
              | grep -E '^[a-zA-Z0-9][a-zA-Z0-9._-]*(:[0-9]+)?/[a-zA-Z0-9][a-zA-Z0-9._/-]*(:[a-zA-Z0-9._-]+)?$|^[a-zA-Z0-9][a-zA-Z0-9._-]*:[a-zA-Z0-9._-]+$|^[a-zA-Z0-9][a-zA-Z0-9._-]*/[a-zA-Z0-9][a-zA-Z0-9._-]*$' | tee -a generic_images.txt >> tmp_images || true
            
            # Also extract FROM tokens in Dockerfiles
            rg -o '^\s*FROM\s+[^\s]+' "$f" --hidden --no-ignore-vcs 2>/dev/null \
              | sed -E 's/^\s*FROM\s+//' \
              | sed -E 's/\s+AS\s+.*//' \
              | grep -E '^[a-zA-Z0-9][a-zA-Z0-9._-]*(:[0-9]+)?/[a-zA-Z0-9][a-zA-Z0-9._/-]*(:[a-zA-Z0-9._-]+)?$|^[a-zA-Z0-9][a-zA-Z0-9._-]*:[a-zA-Z0-9._-]+$|^[a-zA-Z0-9][a-zA-Z0-9._-]*/[a-zA-Z0-9][a-zA-Z0-9._-]*$' | tee -a generic_images.txt >> tmp_images || true
            
            # Extract image values from YAML
            rg -o 'image:\s*[A-Za-z0-9._/-:@]+' "$f" --hidden --no-ignore-vcs 2>/dev/null \
              | sed -E 's/^image:\s*//' \
              | grep -E '^[a-zA-Z0-9][a-zA-Z0-9._-]*(:[0-9]+)?/[a-zA-Z0-9][a-zA-Z0-9._/-]*(:[a-zA-Z0-9._-]+)?$|^[a-zA-Z0-9][a-zA-Z0-9._-]*:[a-zA-Z0-9._-]+$|^[a-zA-Z0-9][a-zA-Z0-9._-]*/[a-zA-Z0-9][a-zA-Z0-9._-]*$' | tee -a generic_images.txt >> tmp_images || true
          done < files_with_images.txt || true
          
          # Display the images found in generic files
          echo "==== Images found in other files ====" | tee -a trivy.log
          if [ -s generic_images.txt ]; then
            cat generic_images.txt | tee -a trivy.log
          else
            echo "No images found in other files." | tee -a trivy.log
          fi
          echo "===================================" | tee -a trivy.log
          
          echo "Image token extraction completed." >> trivy.log

      - name: Dedupe image list
        run: |
          echo "Deduplicating and writing final images.txt..." >> trivy.log
          if [ -f tmp_images ]; then
            sort -u tmp_images > images.txt || true
          else
            touch images.txt
          fi
          
          # Count images found in each type of source
          echo "==== Image Counts by Source ====" | tee -a trivy.log
          echo "Devcontainer images: $([ -f devcontainer_images.txt ] && wc -l < devcontainer_images.txt || echo 0)" | tee -a trivy.log
          echo "Dockerfile images: $([ -f dockerfile_images.txt ] && wc -l < dockerfile_images.txt || echo 0)" | tee -a trivy.log
          echo "Docker Compose images: $([ -f docker_compose_images.txt ] && wc -l < docker_compose_images.txt || echo 0)" | tee -a trivy.log
          echo "Other image references: $([ -f generic_images.txt ] && wc -l < generic_images.txt || echo 0)" | tee -a trivy.log
          echo "Total unique images: $([ -f images.txt ] && wc -l < images.txt || echo 0)" | tee -a trivy.log
          echo "===============================" | tee -a trivy.log
          
          echo "Final images.txt written." >> trivy.log
          
      - name: Filter images.txt for valid Docker image references
        run: |
          echo "Filtering images.txt for valid Docker image references..." >> trivy.log
          
          # Create a temporary file for the filtered images
          touch filtered_images.txt
          
          # Define a more precise regex for Docker image references
          # This specifically looks for common registry patterns and valid image formats
          while IFS= read -r img; do
            # Skip if empty
            [ -z "$img" ] && continue
            
            # Only keep lines that:
            # 1. Start with a known registry (docker.io, ghcr.io, mcr.microsoft.com, etc.)
            # 2. Have a valid Docker image format with tags or digests
            if echo "$img" | grep -E '^(docker\.io/|ghcr\.io/|mcr\.microsoft\.com/|quay\.io/|registry\.hub\.docker\.com/|.*\.azurecr\.io/|.*\.pkg\.dev/|[a-zA-Z0-9][-a-zA-Z0-9]*/[a-zA-Z0-9][-a-zA-Z0-9]*|ubuntu|alpine|debian|centos|fedora|node|python|golang|ruby|openjdk|nginx|redis|postgres|mysql|mongo|elasticsearch|kafka)' > /dev/null; then
              echo "$img" >> filtered_images.txt
            else
              echo "Filtering out non-Docker image: $img" >> trivy.log
            fi
          done < images.txt
          
          # Replace the original images.txt with the filtered version
          mv filtered_images.txt images.txt
          
          # Log the filtering results
          count=$(wc -l < images.txt || echo 0)
          echo "After filtering, found $count valid Docker images" | tee -a trivy.log
          echo "Filtered images.txt written." >> trivy.log
          
          # Log the actual images for visibility
          echo "==== Filtered Docker Images ====" | tee -a trivy.log
          if [ -s images.txt ]; then
            cat images.txt | tee -a trivy.log
          else
            echo "No valid Docker images found after filtering." | tee -a trivy.log
          fi
          echo "===============================" | tee -a trivy.log

      - name: Remove images by not-allowed list prefixes
        run: |
          echo "Removing images that start with not-allowed prefixes..." | tee -a trivy.log

          # Define the not-allowed list prefixes here (edit as needed). Any image line that starts with
          # one of these prefixes will be removed from images.txt.
          PREFIXES=(
            "br"
            "ptn"
            "res"
            "ghcr.io/devcontainers/features/"
          )

          # Files to record removed and kept images
          touch removed_by_prefix.txt kept_images.txt

          echo "Blacklist prefixes:" | tee -a trivy.log
          for p in "${PREFIXES[@]}"; do
            echo " - $p" | tee -a trivy.log
          done

          if [ ! -f images.txt ] || [ ! -s images.txt ]; then
            echo "images.txt missing or empty; nothing to filter by prefix" | tee -a trivy.log
            touch images.txt
          else
            while IFS= read -r img; do
              # skip empty lines
              [ -z "$img" ] && continue
              skip=false
              for p in "${PREFIXES[@]}"; do
                if [[ "$img" == "$p"* ]]; then
                  echo "$img" >> removed_by_prefix.txt
                  skip=true
                  break
                fi
              done
              if [ "$skip" = false ]; then
                echo "$img" >> kept_images.txt
              fi
            done < images.txt

            # Replace images.txt with the kept images
            mv kept_images.txt images.txt || true
          fi

          removed_count=$(wc -l < removed_by_prefix.txt 2>/dev/null || echo 0)
          kept_count=$(wc -l < images.txt 2>/dev/null || echo 0)
          echo "Removed $removed_count images by prefix, $kept_count images remain" | tee -a trivy.log

          if [ -s removed_by_prefix.txt ]; then
            echo "==== Images removed by prefix ====" | tee -a trivy.log
            cat removed_by_prefix.txt | tee -a trivy.log
            echo "==================================" | tee -a trivy.log
          fi

          echo "Prefix-based removal completed." | tee -a trivy.log
      - name: Log final counts
        id: count-output
        run: |
          echo "Logging final counts..." | tee -a trivy.log
          found_count=0
          if [ -f images.txt ]; then
            found_count=$(wc -l < images.txt || echo 0)
          fi
          images_in_files_count=0
          if [ -f files_with_images.txt ]; then
            images_in_files_count=$(wc -l < files_with_images.txt || echo 0)
          fi

          echo "files_found=${images_in_files_count}" >> $GITHUB_OUTPUT
          echo "found=${found_count}" >> $GITHUB_OUTPUT

          echo "==== Summary Counts ====" | tee -a trivy.log
          echo "Files with image references: ${images_in_files_count}" | tee -a trivy.log
          echo "Distinct Docker images found: ${found_count}" | tee -a trivy.log
          echo "======================" | tee -a trivy.log
          
          echo "files_with_images=${images_in_files_count}" >> trivy.log
          echo "found_images_file=${found_count}" >> trivy.log
          echo "Final counts logged." >> trivy.log

          # If stop_workflow is already set to true by Trivy check, don't override it
          if [[ "${stop_workflow:-}" != "true" ]]; then
            if [ "$found_count" -eq 0 ] || [ "$images_in_files_count" -eq 0 ]; then
              echo "Error: No files or images found. Stopping the workflow after uploading the log." | tee -a trivy.log
              echo "stop_workflow=true" >> $GITHUB_ENV
            else
              echo "Docker images found. Continuing the workflow." | tee -a trivy.log
              echo "stop_workflow=false" >> $GITHUB_ENV
            fi
          else
            echo "Trivy installation failed earlier; keeping stop_workflow=true" | tee -a trivy.log
          fi

      - name: Debug stop_workflow variable
        run: |
          echo "stop_workflow==${{ env.stop_workflow }}"

      - name: Upload log artifact
        if: env.stop_workflow == true && env.ACT != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: trivy-log
          path: |
            trivy.log
            candidate_files.txt
            files_with_images.txt
            devcontainer_images.txt
            dockerfile_images.txt
            docker_compose_images.txt
            generic_images.txt

            # Store files in a common location for Act
      - name: Copy files to common location for Act
        if: env.ACT == 'true'
        run: |
          # Create a shared directory that will be accessible across jobs
          sudo mkdir -p /tmp/act-shared-data
          sudo chmod 777 /tmp/act-shared-data
          
          # Copy all the needed files to this shared location
          cp -f images.txt /tmp/act-shared-data/images.txt || touch /tmp/act-shared-data/images.txt
          cp -f files_with_images.txt /tmp/act-shared-data/files_with_images.txt || touch /tmp/act-shared-data/files_with_images.txt
          cp -f trivy.log /tmp/act-shared-data/trivy.log || touch /tmp/act-shared-data/trivy.log
          cp -f candidate_files.txt /tmp/act-shared-data/candidate_files.txt || touch /tmp/act-shared-data/candidate_files.txt
          cp -f devcontainer_images.txt /tmp/act-shared-data/devcontainer_images.txt || touch /tmp/act-shared-data/devcontainer_images.txt
          cp -f dockerfile_images.txt /tmp/act-shared-data/dockerfile_images.txt || touch /tmp/act-shared-data/dockerfile_images.txt
          cp -f docker_compose_images.txt /tmp/act-shared-data/docker_compose_images.txt || touch /tmp/act-shared-data/docker_compose_images.txt
          cp -f generic_images.txt /tmp/act-shared-data/generic_images.txt || touch /tmp/act-shared-data/generic_images.txt
          
          # Ensure the files are accessible to all users
          sudo chmod 666 /tmp/act-shared-data/*
          
          echo "Files copied to shared location for Act:"
          ls -la /tmp/act-shared-data/
          
          # Create an artifact-like log for tracking
          echo "Created find-images-${GITHUB_EVENT_INPUT_REPOOWNER:-local}-${GITHUB_EVENT_INPUT_REPONAME:-repo}-${GITHUB_EVENT_INPUT_RUNID:-test} artifacts" > /tmp/act-shared-data/artifact-log.txt

      # Upload images.txt as an artifact to be used in the next job
      - name: Upload images data
        if: env.ACT != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: find-images-${{ github.event.inputs.repoOwner }}-${{ github.event.inputs.repoName }}-${{ github.event.inputs.runId }}
          path: |
            images.txt
            files_with_images.txt
            trivy.log
            candidate_files.txt
            devcontainer_images.txt
            dockerfile_images.txt
            docker_compose_images.txt
            generic_images.txt

  scan-images:
    name: Scan Docker Images
    needs: find-images
    if: needs.find-images.outputs.stop_workflow != 'true'
    runs-on: ubuntu-latest
    steps:
      # Only checkout the code when not running in Act
      - name: Checkout code
        if: env.ACT != 'true'
        uses: actions/checkout@v4
        with:
          repository: ${{ github.event.inputs.repoOwner }}/${{ github.event.inputs.repoName }}
        continue-on-error: false

      # Download the artifacts from the previous job (only when not running in Act)
      - name: Download image data
        if: env.ACT != 'true'
        uses: actions/download-artifact@v4
        with:
          name: find-images-${{ github.event.inputs.repoOwner }}-${{ github.event.inputs.repoName }}-${{ github.event.inputs.runId }}
          
            # When running with Act, get files from shared location
      - name: Get files from shared location (Act only)
        if: env.ACT == 'true'
        run: |
          echo "Running in Act mode - retrieving files from shared location..."
          
          # Ensure the directory exists
          sudo mkdir -p /tmp/act-shared-data
          
          # List the shared directory contents
          echo "Shared directory contents:"
          ls -la /tmp/act-shared-data/ || echo "Shared directory not found"
          
          # Ensure files exist to prevent errors
          touch images.txt trivy.log files_with_images.txt candidate_files.txt
          
          # Copy files from shared location to current working directory
          cp -f /tmp/act-shared-data/images.txt ./ || echo "images.txt not found in shared location"
          cp -f /tmp/act-shared-data/files_with_images.txt ./ || echo "files_with_images.txt not found in shared location" 
          cp -f /tmp/act-shared-data/trivy.log ./ || echo "trivy.log not found in shared location"
          cp -f /tmp/act-shared-data/candidate_files.txt ./ || echo "candidate_files.txt not found in shared location"
          cp -f /tmp/act-shared-data/devcontainer_images.txt ./ 2>/dev/null || echo "devcontainer_images.txt not found"
          cp -f /tmp/act-shared-data/dockerfile_images.txt ./ 2>/dev/null || echo "dockerfile_images.txt not found"
          cp -f /tmp/act-shared-data/docker_compose_images.txt ./ 2>/dev/null || echo "docker_compose_images.txt not found"
          cp -f /tmp/act-shared-data/generic_images.txt ./ 2>/dev/null || echo "generic_images.txt not found"
          
          echo "Using artifact from:"
          cat /tmp/act-shared-data/artifact-log.txt 2>/dev/null || echo "No artifact log found"
          
          echo "Current directory contents after copying:"
          ls -la

      - name: Log found images
        run: |
          # Ensure files exist
          touch images.txt trivy.log devcontainer_images.txt dockerfile_images.txt docker_compose_images.txt generic_images.txt
          
          # record both the step output and the actual images.txt line count
          echo "found_images_output=${{ needs.find-images.outputs.found_count }}" >> trivy.log
          echo "found_files_output=${{ needs.find-images.outputs.files_found }}" >> trivy.log
          
          # Check if images.txt has content before trying to count lines
          if [ -s images.txt ]; then
            echo "found_images_file=$(wc -l < images.txt)" >> trivy.log
          else
            echo "found_images_file=0" >> trivy.log
          fi
          
          # Log the images found in each extraction method
          echo "==== Images found in devcontainer.json files ====" | tee -a trivy.log
          if [ -s devcontainer_images.txt ]; then
            cat devcontainer_images.txt | tee -a trivy.log
          else
            echo "No images found in devcontainer.json files." | tee -a trivy.log
          fi
          echo "=================================================" | tee -a trivy.log
          
          echo "==== Images found in Dockerfiles ====" | tee -a trivy.log
          if [ -s dockerfile_images.txt ]; then
            cat dockerfile_images.txt | tee -a trivy.log
          else
            echo "No images found in Dockerfiles." | tee -a trivy.log
          fi
          echo "====================================" | tee -a trivy.log
          
          echo "==== Images found in Docker Compose files ====" | tee -a trivy.log
          if [ -s docker_compose_images.txt ]; then
            cat docker_compose_images.txt | tee -a trivy.log
          else
            echo "No images found in Docker Compose files." | tee -a trivy.log
          fi
          echo "=============================================" | tee -a trivy.log
          
          echo "==== Images found in other files ====" | tee -a trivy.log
          if [ -s generic_images.txt ]; then
            cat generic_images.txt | tee -a trivy.log
          else
            echo "No images found in other files." | tee -a trivy.log
          fi
          echo "===================================" | tee -a trivy.log
          
          # Log the actual images for visibility in both run output and log file
          echo "==== All Found Docker Images (Deduplicated) ====" | tee -a trivy.log
          if [ -s images.txt ]; then
            cat images.txt | tee -a trivy.log
          else
            echo "No Docker images found." | tee -a trivy.log
          fi
          echo "=============================================" | tee -a trivy.log

      - name: Install Trivy CLI
        run: |
          echo "Attempting to install Trivy..." | tee -a trivy.log
          set +e
          curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin
          set -e
          
          # This gets checked in the subsequent Verify step

      - name: Debug stop_workflow variable
        run: |
          echo "stop_workflow==${{ needs.find-images.outputs.stop_workflow }}"

      - name: Verify Trivy is installed
        run: |
          echo "Verifying trivy is installed..." | tee -a trivy.log
          if command -v trivy >/dev/null 2>&1; then
            trivy --version | tee -a trivy.log
            echo "trivy_installed=true" >> $GITHUB_ENV
          else
            echo "Error: trivy CLI not found. Will skip scan steps." | tee -a trivy.log
            echo "trivy_installed=false" >> $GITHUB_ENV
          fi

      - name: Init scan log
        if: env.trivy_installed == 'true'
        run: |
          echo "Trivy scan started: $(date -u)" > trivy.log
          echo "repo=${{ github.event.inputs.repoOwner }}/${{ github.event.inputs.repoName }}" >> trivy.log
          echo "run_id=${{ github.event.inputs.runId }}" >> trivy.log
          echo "found_images=$(wc -l < images.txt)" >> trivy.log

      - name: Scan repository 
        if: env.trivy_installed == 'true'
        run: |
          echo "Starting repository scan for ${{ github.event.inputs.repoOwner }}/${{ github.event.inputs.repoName }}" | tee -a trivy.log

          # Run a repo scan of the checked-out repository and save JSON
          echo "Running trivy scan in $(pwd)" | tee -a trivy.log
          trivy repo https://github.com/${{ github.event.inputs.repoOwner }}/${{ github.event.inputs.repoName }} --scanners misconfig --scanners license --scanners vuln --scanners secret --format json -o scan_repo.json . 2>> trivy.log || echo "trivy repo scan exited with non-zero status" >> trivy.log

          # Log summary info
          if [ -f scan_repo.json ]; then
            echo "Wrote scan_repo.json ($(wc -c < scan_repo.json) bytes)" | tee -a trivy.log
          else
            echo "scan_repo.json not created" | tee -a trivy.log
          fi

      - name: Scan discovered images
        if: env.trivy_installed == 'true'
        run: |
          mkdir -p trivy-output
          
          # Check if images.txt exists and is not empty
          if [ ! -s images.txt ]; then
            echo "Error: images.txt is empty or doesn't exist" | tee -a trivy.log
            touch images.txt  # Create empty file if missing
          fi
          
          while IFS= read -r img; do
            # Skip empty lines
            [ -z "$img" ] && continue
            
            # sanitize name for filename (replace /:@sha256 etc)
            file=$(echo "$img" | sed -E 's/[^A-Za-z0-9._-]/_/g')
            echo "Scanning $img -> ${file}.json" | tee -a trivy.log
            if trivy image --quiet --format json -o "${file}.json" "$img"; then
              echo "SUCCESS: $img" >> trivy.log
            else
              echo "FAILED: $img" >> trivy.log
              echo "scan failed for $img" > "failures/${file}.scan_error"
              echo "scan failed for $img" >> trivy.log
            fi
          done < images.txt

      - name: Create combined summary.json
        if: env.trivy_installed == 'true'
        run: |
          mkdir -p combined
          echo "Generating summary at $(date -u)" | tee -a trivy.log
          
          # Check if trivy-output directory exists and has json files
          if [ -d "trivy-output" ] && ls *.json >/dev/null 2>&1; then
            # attempt to build an aggregated summary; log jq output & errors
            if jq -s 'def allv: (map(.Results // []) | map(.[] | .Vulnerabilities // []) | add // []); {
              total: (allv | length),
              by_severity: (allv | group_by(.Severity) | map({(.[0].Severity): length}) | add // {}),
              per_file: (map({file: input_filename, total: ((.Results[]?.Vulnerabilities // []) | length)}) )
            }' *.json > summary.json 2>> trivy.log; then
              echo "Summary generated: $(wc -c < summary.json) bytes" >> trivy.log
            else
              echo "Summary generation failed; writing default summary" >> trivy.log
              echo '{"total":0}' > summary.json
            fi
          else
            echo "No JSON files found in trivy-output directory; writing default summary" >> trivy.log
            echo '{"total":0}' > summary.json
          fi

      - name: Upload Trivy outputs artifacts
        if: env.ACT != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: scan-${{ github.event.inputs.repoOwner }}-${{ github.event.inputs.repoName }}-${{ github.event.inputs.runId }}
          path: |
            *.json
            trivy.log
            failures/*