name: Trivy image scans

# Images that can't be scanned:
# Private images (need auth)
# Devcontainer features (aren't real images)

# touch
on:
  workflow_dispatch:
    inputs:
      repoOwner:
        description: 'Repository owner'
        required: true
        type: string
      repoName:
        description: 'Repository name'
        required: true
        type: string
      runId:
        description: 'Unique identifier for the workflow run (for tracking purposes)'
        required: true
        type: string
        default: ''

permissions:
  contents: read
  security-events: write # Required for uploading Trivy scan results to GitHub Security tab
  actions: read # To read workflow run status


jobs:
  find-images:
    name: Find Docker Images
    runs-on: ubuntu-latest
    outputs:
      stop_workflow: ${{ env.stop_workflow }}
      found_count: ${{ steps.count-output.outputs.found }}
      files_found: ${{ steps.count-output.outputs.files_found }}
    steps:
      - name: Debug log file
        run: |
          echo "Contents of trivy.log:"
          cat trivy.log || echo "trivy.log not found"

      - name: Validate inputs
        run: |
          if [ -z "${{ github.event.inputs.repoOwner }}" ]; then
            echo "Error: repoOwner input is required."
            exit 1
          fi
          if [ -z "${{ github.event.inputs.repoName }}" ]; then
            echo "Error: repoName input is required."
            exit 1
          fi
          if [ -z "${{ github.event.inputs.runId }}" ]; then
            echo "Error: runId input is required."
            exit 1
          fi

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          repository: ${{ github.event.inputs.repoOwner }}/${{ github.event.inputs.repoName }}
        continue-on-error: false

      - name: Set up tool cache directory
        run: |
          sudo mkdir -p /opt/tool-cache
          sudo chmod 777 /opt/tool-cache

      - name: Cache installed tools
        id: cache-tools
        uses: actions/cache@v3
        with:
          path: /opt/tool-cache
          key: ${{ runner.os }}-tools-cache-v1-${{ hashFiles('**/trivy.yml') }}
          restore-keys: |
            ${{ runner.os }}-tools-cache-v1-

      - name: Install required tools
        run: |
          echo "Installing required tools..." >> trivy.log
          sudo apt-get update
          
          if [ "${{ steps.cache-tools.outputs.cache-hit }}" == "true" ]; then
            echo "Using cached tools" >> trivy.log
            if [ -f /opt/tool-cache/ripgrep.deb ]; then
              sudo dpkg -i /opt/tool-cache/ripgrep.deb || sudo apt-get -f install -y
            else
              sudo apt-get install -y ripgrep
              ripgrep_deb=$(find /var/cache/apt/archives/ -name "ripgrep*.deb" | head -1)
              if [ -n "$ripgrep_deb" ]; then
                cp "$ripgrep_deb" /opt/tool-cache/ripgrep.deb
              fi
            fi
            
            if [ -f /opt/tool-cache/jq.deb ]; then
              sudo dpkg -i /opt/tool-cache/jq.deb || sudo apt-get -f install -y
            else
              sudo apt-get install -y jq
              jq_deb=$(find /var/cache/apt/archives/ -name "jq*.deb" | head -1)
              if [ -n "$jq_deb" ]; then
                cp "$jq_deb" /opt/tool-cache/jq.deb
              fi
            fi
          else
            echo "Installing fresh tools" >> trivy.log
            sudo apt-get install -y ripgrep jq
            
            # Store the installed packages in our cache directory
            ripgrep_deb=$(find /var/cache/apt/archives/ -name "ripgrep*.deb" | head -1)
            if [ -n "$ripgrep_deb" ]; then
              cp "$ripgrep_deb" /opt/tool-cache/ripgrep.deb
            fi
            
            jq_deb=$(find /var/cache/apt/archives/ -name "jq*.deb" | head -1)
            if [ -n "$jq_deb" ]; then
              cp "$jq_deb" /opt/tool-cache/jq.deb
            fi
          fi
          
          echo "Required tools installed." >> trivy.log



      - name: Remove old files
        run: |
          set -euo pipefail
          echo "Removing old files..." >> trivy.log
          rm -f candidate_files.txt files_with_images.txt tmp_images images.txt devcontainer_images.txt dockerfile_images.txt docker_compose_images.txt generic_images.txt || true
          echo "Old files removed." >> trivy.log

      - name: Find candidate files by filename patterns
        run: |
          echo "Finding candidate files by filename patterns..." >> trivy.log
          find . -type f \( \
            -iname 'Dockerfile*' -o \
            -iname '*docker-compose*.yml' -o \
            -iname '*docker-compose*.yaml' -o \
            -path './.devcontainer/*' -o \
            -iname '*.devcontainer.json' -o \
            -iname '*.bicep' -o \
            -iname '*.tf' -o \
            -iname '*.yaml' -o \
            -iname '*.yml' \
          \) -not -path './.git/*' -print > candidate_files.txt || true
          echo "Candidate file search completed." >> trivy.log

      - name: Log candidate files
        run: |
          echo "Logging candidate files..." >> trivy.log
          echo "candidate_files_count=$(wc -l < candidate_files.txt 2>/dev/null || echo 0)" >> trivy.log
          echo "candidate_files:" >> trivy.log
          if [ -s candidate_files.txt ]; then
            sed 's/^/ - /' candidate_files.txt >> trivy.log
          else
            echo " - (none)" >> trivy.log
          fi
          echo "Candidate files logged." >> trivy.log

      - name: Filter candidate files for image-like content
        run: |
          echo "Filtering candidate files for image-like content..." >> trivy.log
          while IFS= read -r f; do
            # Skip if empty
            [ -z "$f" ] && continue

            echo "Processing file: $f" >> trivy.log

            # Check for common hints: 'image:' key, FROM lines, or any registry-looking token
            if rg -n --hidden --no-ignore-vcs --glob '!.git/**' -e '^\s*image\s*:' -e '^\s*FROM\s+' -e '([a-z0-9.-]+(?::[0-9]+)?/)[A-Za-z0-9._/-]+' "$f" > /dev/null 2>&1; then
              echo "File contains image-like content: $f" >> trivy.log
              echo "$f" >> files_with_images.txt
            else
              echo "No image-like content found in file: $f" >> trivy.log
            fi
          done < candidate_files.txt || true
          echo "Filtering completed." >> trivy.log



      - name: Extract image values from .devcontainer.json files
        run: |
          echo "Extracting image values from .devcontainer.json files..." >> trivy.log
          # Find all .devcontainer.json files
          find . -type f -name 'devcontainer.json' -o -path '**/.devcontainer/devcontainer.json' -not -path './.git/*' > devcontainer_files.txt || true

          # Create a separate file for devcontainer images
          touch devcontainer_images.txt

          # Check if any .devcontainer.json files were found
          if [ -s devcontainer_files.txt ]; then
            echo "Found devcontainer.json files:" >> trivy.log
            cat devcontainer_files.txt >> trivy.log
            while IFS= read -r file; do
              echo "Scanning file: $file" >> trivy.log
              # Extract the "image" value from the JSON file
              # Use a more permissive filter that still excludes non-image values
              jq -r '.image // empty' "$file" | grep -E '^[a-zA-Z0-9][a-zA-Z0-9._-]*(:[0-9]+)?/[a-zA-Z0-9][a-zA-Z0-9._/-]*(:[a-zA-Z0-9._-]+)?$|^[a-zA-Z0-9][a-zA-Z0-9._-]*:[a-zA-Z0-9._-]+$|^[a-zA-Z0-9][a-zA-Z0-9._-]*/[a-zA-Z0-9][a-zA-Z0-9._-]*$' | tee -a devcontainer_images.txt >> tmp_images || true
            done < devcontainer_files.txt
          else
            echo "No devcontainer.json files found." >> trivy.log
          fi

          # Display the images found in devcontainer.json files
          echo "==== Images found in devcontainer.json files ====" | tee -a trivy.log
          if [ -s devcontainer_images.txt ]; then
            cat devcontainer_images.txt | tee -a trivy.log
          else
            echo "No images found in devcontainer.json files." | tee -a trivy.log
          fi
          echo "=================================================" | tee -a trivy.log

          echo "Image extraction from .devcontainer.json files completed." >> trivy.log

      - name: Debug .devcontainer.json parsing
        run: |
          echo "Debugging .devcontainer.json parsing..." >> trivy.log
          while IFS= read -r file; do
            echo "Scanning file: $file" >> trivy.log
            jq -r '.image // empty' "$file" >> trivy.log || echo "jq failed for $file" >> trivy.log
          done < devcontainer_files.txt
          echo "Debugging completed." >> trivy.log


      - name: Extract image values from Dockerfiles
        run: |
          echo "Extracting image values from Dockerfiles..." >> trivy.log
          # Find all Dockerfiles
          find . -type f -iname 'Dockerfile*' -not -path './.git/*' > dockerfile_files.txt || true

          # Create a separate file for Dockerfile images
          touch dockerfile_images.txt

          # Log the found Dockerfiles
          echo "Found Dockerfiles:" >> trivy.log
          if [ -s dockerfile_files.txt ]; then
            cat dockerfile_files.txt >> trivy.log
          else
            echo "No Dockerfiles found." >> trivy.log
          fi

          # Extract "FROM" values with a more permissive filter
          if [ -s dockerfile_files.txt ]; then
            while IFS= read -r file; do
              echo "Scanning file: $file" >> trivy.log
              rg -o '^\s*FROM\s+[^\s]+' "$file" --hidden --no-ignore-vcs 2>/dev/null \
                | sed -E 's/^\s*FROM\s+//' \
                | sed -E 's/\s+AS\s+.*//' \
                | grep -E '^[a-zA-Z0-9][a-zA-Z0-9._-]*(:[0-9]+)?/[a-zA-Z0-9][a-zA-Z0-9._/-]*(:[a-zA-Z0-9._-]+)?$|^[a-zA-Z0-9][a-zA-Z0-9._-]*:[a-zA-Z0-9._-]+$|^[a-zA-Z0-9][a-zA-Z0-9._-]*/[a-zA-Z0-9][a-zA-Z0-9._-]*$' | tee -a dockerfile_images.txt >> tmp_images || true
            done < dockerfile_files.txt
          fi

          # Display the images found in Dockerfiles
          echo "==== Images found in Dockerfiles ====" | tee -a trivy.log
          if [ -s dockerfile_images.txt ]; then
            cat dockerfile_images.txt | tee -a trivy.log
          else
            echo "No images found in Dockerfiles." | tee -a trivy.log
          fi
          echo "====================================" | tee -a trivy.log

          echo "Image extraction from Dockerfiles completed." >> trivy.log

      - name: Debug Dockerfile parsing
        run: |
          echo "Debugging Dockerfile parsing..." >> trivy.log
          while IFS= read -r file; do
            echo "Scanning file: $file" >> trivy.log
            rg -o '^\s*FROM\s+[^\s]+' "$file" --hidden --no-ignore-vcs 2>>trivy.log \
              | sed -E 's/^\s*FROM\s+//' \
              | sed -E 's/\s+AS\s+.*//' >> trivy.log || echo "rg failed for $file" >> trivy.log
          done < dockerfile_files.txt
          echo "Debugging completed." >> trivy.log


      - name: Extract image values from Docker Compose files
        run: |
          echo "Extracting image values from Docker Compose files..." >> trivy.log
          # Find all Docker Compose files
          find . -type f \( -iname '*docker-compose*.yml' -o -iname '*docker-compose*.yaml' \) -not -path './.git/*' > docker_compose_files.txt || true

          # Create a separate file for Docker Compose images
          touch docker_compose_images.txt

          # Log the found Docker Compose files
          echo "Found Docker Compose files:" >> trivy.log
          if [ -s docker_compose_files.txt ]; then
            cat docker_compose_files.txt >> trivy.log
          else
            echo "No Docker Compose files found." >> trivy.log
          fi

          # Extract "image" values and filter for valid Docker image formats
          if [ -s docker_compose_files.txt ]; then
            while IFS= read -r file; do
              echo "Scanning file: $file" >> trivy.log
              # Extract the "image" values from the YAML file
              rg -o '^\s*image:\s*[^\s]+' "$file" --hidden --no-ignore-vcs 2>/dev/null \
                | sed -E 's/^\s*image:\s*//' \
                | grep -E '^[a-zA-Z0-9][a-zA-Z0-9._-]*(:[0-9]+)?/[a-zA-Z0-9][a-zA-Z0-9._/-]*(:[a-zA-Z0-9._-]+)?$|^[a-zA-Z0-9][a-zA-Z0-9._-]*:[a-zA-Z0-9._-]+$|^[a-zA-Z0-9][a-zA-Z0-9._-]*/[a-zA-Z0-9][a-zA-Z0-9._-]*$' | tee -a docker_compose_images.txt >> tmp_images || true
            done < docker_compose_files.txt
          fi

          # Display the images found in Docker Compose files
          echo "==== Images found in Docker Compose files ====" | tee -a trivy.log
          if [ -s docker_compose_images.txt ]; then
            cat docker_compose_images.txt | tee -a trivy.log
          else
            echo "No images found in Docker Compose files." | tee -a trivy.log
          fi
          echo "=============================================" | tee -a trivy.log

          echo "Image extraction from Docker Compose files completed." >> trivy.log

      - name: Extract image tokens from discovered files
        run: |
          echo "Extracting image tokens from discovered files..." >> trivy.log
          
          # Create a separate file for generic image tokens
          touch generic_images.txt
          
          while IFS= read -r f; do
            [ -z "$f" ] && continue
            echo "Scanning file: $f" >> trivy.log
            
            # Extract image references with a more permissive filter
            rg -o '([a-zA-Z0-9][a-zA-Z0-9._-]*(?::[0-9]+)?/)?[a-zA-Z0-9][a-zA-Z0-9._/-]*(?::[a-zA-Z0-9._-]+|@sha256:[a-f0-9]{64})' --hidden --no-ignore-vcs "$f" \
              | grep -v -E '(localhost|127\.0\.0\.1)' \
              | grep -E '^[a-zA-Z0-9][a-zA-Z0-9._-]*(:[0-9]+)?/[a-zA-Z0-9][a-zA-Z0-9._/-]*(:[a-zA-Z0-9._-]+)?$|^[a-zA-Z0-9][a-zA-Z0-9._-]*:[a-zA-Z0-9._-]+$|^[a-zA-Z0-9][a-zA-Z0-9._-]*/[a-zA-Z0-9][a-zA-Z0-9._-]*$' | tee -a generic_images.txt >> tmp_images || true
            
            # Also extract FROM tokens in Dockerfiles
            rg -o '^\s*FROM\s+[^\s]+' "$f" --hidden --no-ignore-vcs 2>/dev/null \
              | sed -E 's/^\s*FROM\s+//' \
              | sed -E 's/\s+AS\s+.*//' \
              | grep -E '^[a-zA-Z0-9][a-zA-Z0-9._-]*(:[0-9]+)?/[a-zA-Z0-9][a-zA-Z0-9._/-]*(:[a-zA-Z0-9._-]+)?$|^[a-zA-Z0-9][a-zA-Z0-9._-]*:[a-zA-Z0-9._-]+$|^[a-zA-Z0-9][a-zA-Z0-9._-]*/[a-zA-Z0-9][a-zA-Z0-9._-]*$' | tee -a generic_images.txt >> tmp_images || true
            
            # Extract image values from YAML
            rg -o 'image:\s*[A-Za-z0-9._/-:@]+' "$f" --hidden --no-ignore-vcs 2>/dev/null \
              | sed -E 's/^image:\s*//' \
              | grep -E '^[a-zA-Z0-9][a-zA-Z0-9._-]*(:[0-9]+)?/[a-zA-Z0-9][a-zA-Z0-9._/-]*(:[a-zA-Z0-9._-]+)?$|^[a-zA-Z0-9][a-zA-Z0-9._-]*:[a-zA-Z0-9._-]+$|^[a-zA-Z0-9][a-zA-Z0-9._-]*/[a-zA-Z0-9][a-zA-Z0-9._-]*$' | tee -a generic_images.txt >> tmp_images || true
          done < files_with_images.txt || true
          
          # Display the images found in generic files
          echo "==== Images found in other files ====" | tee -a trivy.log
          if [ -s generic_images.txt ]; then
            cat generic_images.txt | tee -a trivy.log
          else
            echo "No images found in other files." | tee -a trivy.log
          fi
          echo "===================================" | tee -a trivy.log
          
          echo "Image token extraction completed." >> trivy.log

      - name: Dedupe image list
        run: |
          echo "Deduplicating and writing final images.txt..." >> trivy.log
          if [ -f tmp_images ]; then
            sort -u tmp_images > images.txt || true
          else
            touch images.txt
          fi
          
          # Count images found in each type of source
          echo "==== Image Counts by Source ====" | tee -a trivy.log
          echo "Devcontainer images: $([ -f devcontainer_images.txt ] && wc -l < devcontainer_images.txt || echo 0)" | tee -a trivy.log
          echo "Dockerfile images: $([ -f dockerfile_images.txt ] && wc -l < dockerfile_images.txt || echo 0)" | tee -a trivy.log
          echo "Docker Compose images: $([ -f docker_compose_images.txt ] && wc -l < docker_compose_images.txt || echo 0)" | tee -a trivy.log
          echo "Other image references: $([ -f generic_images.txt ] && wc -l < generic_images.txt || echo 0)" | tee -a trivy.log
          echo "Total unique images: $([ -f images.txt ] && wc -l < images.txt || echo 0)" | tee -a trivy.log
          echo "===============================" | tee -a trivy.log
          
          echo "Final images.txt written." >> trivy.log
          
      - name: Filter images.txt for valid Docker image references
        run: |
          echo "Filtering images.txt for valid Docker image references..." >> trivy.log
          
          # Create a temporary file for the filtered images
          touch filtered_images.txt
          
          # Define a more precise regex for Docker image references
          # This specifically looks for common registry patterns and valid image formats
          while IFS= read -r img; do
            # Skip if empty
            [ -z "$img" ] && continue
            
            # Only keep lines that:
            # 1. Start with a known registry (docker.io, ghcr.io, mcr.microsoft.com, etc.)
            # 2. Have a valid Docker image format with tags or digests
            if echo "$img" | grep -E '^(docker\.io/|ghcr\.io/|mcr\.microsoft\.com/|quay\.io/|registry\.hub\.docker\.com/|.*\.azurecr\.io/|.*\.pkg\.dev/|[a-zA-Z0-9][-a-zA-Z0-9]*/[a-zA-Z0-9][-a-zA-Z0-9]*|ubuntu|alpine|debian|centos|fedora|node|python|golang|ruby|openjdk|nginx|redis|postgres|mysql|mongo|elasticsearch|kafka)' > /dev/null; then
              echo "$img" >> filtered_images.txt
            else
              echo "Filtering out non-Docker image: $img" >> trivy.log
            fi
          done < images.txt
          
          # Replace the original images.txt with the filtered version
          mv filtered_images.txt images.txt
          
          # Log the filtering results
          count=$(wc -l < images.txt || echo 0)
          echo "After filtering, found $count valid Docker images" | tee -a trivy.log
          echo "Filtered images.txt written." >> trivy.log
          
          # Log the actual images for visibility
          echo "==== Filtered Docker Images ====" | tee -a trivy.log
          if [ -s images.txt ]; then
            cat images.txt | tee -a trivy.log
          else
            echo "No valid Docker images found after filtering." | tee -a trivy.log
          fi
          echo "===============================" | tee -a trivy.log

      - name: Remove images by not-allowed list prefixes
        run: |
          echo "Removing images that start with not-allowed prefixes..." | tee -a trivy.log

          # Define the not-allowed list prefixes here (edit as needed). Any image line that starts with
          # one of these prefixes will be removed from images.txt.
          PREFIXES=(
            "br"
            "ptn"
            "res"
            "ghcr.io/devcontainers/features/"
          )

          # Files to record removed and kept images
          touch removed_by_prefix.txt kept_images.txt

          echo "Blacklist prefixes:" | tee -a trivy.log
          for p in "${PREFIXES[@]}"; do
            echo " - $p" | tee -a trivy.log
          done

          if [ ! -f images.txt ] || [ ! -s images.txt ]; then
            echo "images.txt missing or empty; nothing to filter by prefix" | tee -a trivy.log
            touch images.txt
          else
            while IFS= read -r img; do
              # skip empty lines
              [ -z "$img" ] && continue
              skip=false
              for p in "${PREFIXES[@]}"; do
                if [[ "$img" == "$p"* ]]; then
                  echo "$img" >> removed_by_prefix.txt
                  skip=true
                  break
                fi
              done
              if [ "$skip" = false ]; then
                echo "$img" >> kept_images.txt
              fi
            done < images.txt

            # Replace images.txt with the kept images
            mv kept_images.txt images.txt || true
          fi

          removed_count=$(wc -l < removed_by_prefix.txt 2>/dev/null || echo 0)
          kept_count=$(wc -l < images.txt 2>/dev/null || echo 0)
          echo "Removed $removed_count images by prefix, $kept_count images remain" | tee -a trivy.log

          if [ -s removed_by_prefix.txt ]; then
            echo "==== Images removed by prefix ====" | tee -a trivy.log
            cat removed_by_prefix.txt | tee -a trivy.log
            echo "==================================" | tee -a trivy.log
          fi

          echo "Prefix-based removal completed." | tee -a trivy.log
      - name: Log final counts
        id: count-output
        run: |
          echo "Logging final counts..." | tee -a trivy.log
          found_count=0
          if [ -f images.txt ]; then
            found_count=$(wc -l < images.txt || echo 0)
          fi
          images_in_files_count=0
          if [ -f files_with_images.txt ]; then
            images_in_files_count=$(wc -l < files_with_images.txt || echo 0)
          fi

          echo "files_found=${images_in_files_count}" >> $GITHUB_OUTPUT
          echo "found=${found_count}" >> $GITHUB_OUTPUT

          echo "==== Summary Counts ====" | tee -a trivy.log
          echo "Files with image references: ${images_in_files_count}" | tee -a trivy.log
          echo "Distinct Docker images found: ${found_count}" | tee -a trivy.log
          echo "======================" | tee -a trivy.log
          
          echo "files_with_images=${images_in_files_count}" >> trivy.log
          echo "found_images_file=${found_count}" >> trivy.log
          echo "Final counts logged." >> trivy.log

          # If stop_workflow is already set to true by Trivy check, don't override it
          if [[ "${stop_workflow:-}" != "true" ]]; then
            if [ "$found_count" -eq 0 ] || [ "$images_in_files_count" -eq 0 ]; then
              echo "Error: No files or images found. Stopping the workflow after uploading the log." | tee -a trivy.log
              echo "stop_workflow=true" >> $GITHUB_ENV
            else
              echo "Docker images found. Continuing the workflow." | tee -a trivy.log
              echo "stop_workflow=false" >> $GITHUB_ENV
            fi
          else
            echo "Trivy installation failed earlier; keeping stop_workflow=true" | tee -a trivy.log
          fi

      - name: Debug stop_workflow variable
        run: |
          echo "stop_workflow==${{ env.stop_workflow }}"

      - name: Upload log artifact
        if: env.stop_workflow == true && env.ACT != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: trivy-log
          path: |
            trivy.log
            candidate_files.txt
            files_with_images.txt
            devcontainer_images.txt
            dockerfile_images.txt
            docker_compose_images.txt
            generic_images.txt

            # Store files in a common location for Act
      - name: Copy files to common location for Act
        if: env.ACT == 'true'
        run: |
          # Create a shared directory that will be accessible across jobs
          sudo mkdir -p /tmp/act-shared-data
          sudo chmod 777 /tmp/act-shared-data
          
          # Copy all the needed files to this shared location
          cp -f images.txt /tmp/act-shared-data/images.txt || touch /tmp/act-shared-data/images.txt
          cp -f files_with_images.txt /tmp/act-shared-data/files_with_images.txt || touch /tmp/act-shared-data/files_with_images.txt
          cp -f trivy.log /tmp/act-shared-data/trivy.log || touch /tmp/act-shared-data/trivy.log
          cp -f candidate_files.txt /tmp/act-shared-data/candidate_files.txt || touch /tmp/act-shared-data/candidate_files.txt
          cp -f devcontainer_images.txt /tmp/act-shared-data/devcontainer_images.txt || touch /tmp/act-shared-data/devcontainer_images.txt
          cp -f dockerfile_images.txt /tmp/act-shared-data/dockerfile_images.txt || touch /tmp/act-shared-data/dockerfile_images.txt
          cp -f docker_compose_images.txt /tmp/act-shared-data/docker_compose_images.txt || touch /tmp/act-shared-data/docker_compose_images.txt
          cp -f generic_images.txt /tmp/act-shared-data/generic_images.txt || touch /tmp/act-shared-data/generic_images.txt
          
          # Ensure the files are accessible to all users
          sudo chmod 666 /tmp/act-shared-data/*
          
          echo "Files copied to shared location for Act:"
          ls -la /tmp/act-shared-data/
          
          # Create an artifact-like log for tracking
          echo "Created find-images-${GITHUB_EVENT_INPUT_REPOOWNER:-local}-${GITHUB_EVENT_INPUT_REPONAME:-repo}-${GITHUB_EVENT_INPUT_RUNID:-test} artifacts" > /tmp/act-shared-data/artifact-log.txt

      # Upload images.txt as an artifact to be used in the next job
      - name: Upload images data
        if: env.ACT != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: find-images-${{ github.event.inputs.repoOwner }}-${{ github.event.inputs.repoName }}-${{ github.event.inputs.runId }}
          path: |
            images.txt
            files_with_images.txt
            trivy.log
            candidate_files.txt
            devcontainer_images.txt
            dockerfile_images.txt
            docker_compose_images.txt
            generic_images.txt


  scan-repo:
    name: Scan Repository
    needs: find-images
    if: needs.find-images.outputs.stop_workflow != 'true'
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/aquasecurity/trivy:latest
    steps:
      - name: Trivy scan repo
        run: |
          set +e
          # set repo name to input ${{ github.event.inputs.repoOwner }}/${{ github.event.inputs.repoName }}
          echo "Scanning repository ${{ github.event.inputs.repoOwner }}/${{ github.event.inputs.repoName }}" | tee -a trivy-repo-scan.log
          trivy repo https://github.com/${{ github.event.inputs.repoOwner }}/${{ github.event.inputs.repoName }} --format json -o trivy-repo-scan.json .
          status=$?
          if [ $status -eq 0 ]; then
            echo "SUCCESS: Repository scan completed" >> trivy-repo-scan.log
          else
            echo "FAILED: Repository scan encountered errors" >> trivy-repo-scan.log
            echo "Repository scan failed (exit code $status)" >> trivy-repo-scan.log
          fi
          set -e

      # Upload images.txt as an artifact to be used in the next job
      - name: Upload images data
        if: env.ACT != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: scan-repo-${{ github.event.inputs.repoOwner }}-${{ github.event.inputs.repoName }}-${{ github.event.inputs.runId }}
          path: |
            trivy-repo-scan.log
            trivy-repo-scan.json

  scan-images:
    name: Scan Docker Images
    needs: find-images
    if: needs.find-images.outputs.stop_workflow != 'true'
    runs-on: ubuntu-latest
    steps:
      # Checkout and download artifacts as before
      - name: Checkout code
        if: env.ACT != 'true'
        uses: actions/checkout@v4
        with:
          repository: ${{ github.event.inputs.repoOwner }}/${{ github.event.inputs.repoName }}
        continue-on-error: false

      - name: Download image data
        if: env.ACT != 'true'
        uses: actions/download-artifact@v4
        with:
          name: find-images-${{ github.event.inputs.repoOwner }}-${{ github.event.inputs.repoName }}-${{ github.event.inputs.runId }}

      - name: Get files from shared location (Act only)
        if: env.ACT == 'true'
        run: |
          echo "Running in Act mode - retrieving files from shared location..."
          sudo mkdir -p /tmp/act-shared-data
          echo "Shared directory contents:"
          ls -la /tmp/act-shared-data/ || echo "Shared directory not found"
          touch images.txt trivy.log files_with_images.txt candidate_files.txt
          cp -f /tmp/act-shared-data/images.txt ./ || echo "images.txt not found in shared location"
          cp -f /tmp/act-shared-data/files_with_images.txt ./ || echo "files_with_images.txt not found in shared location" 
          cp -f /tmp/act-shared-data/trivy.log ./ || echo "trivy.log not found in shared location"
          cp -f /tmp/act-shared-data/candidate_files.txt ./ || echo "candidate_files.txt not found in shared location"
          cp -f /tmp/act-shared-data/devcontainer_images.txt ./ 2>/dev/null || echo "devcontainer_images.txt not found"
          cp -f /tmp/act-shared-data/dockerfile_images.txt ./ 2>/dev/null || echo "dockerfile_images.txt not found"
          cp -f /tmp/act-shared-data/docker_compose_images.txt ./ 2>/dev/null || echo "docker_compose_images.txt not found"
          cp -f /tmp/act-shared-data/generic_images.txt ./ 2>/dev/null || echo "generic_images.txt not found"
          echo "Using artifact from:"
          cat /tmp/act-shared-data/artifact-log.txt 2>/dev/null || echo "No artifact log found"
          echo "Current directory contents after copying:"
          ls -la

      # Generate matrix from images.txt
      - name: Generate image matrix
        id: matrix
        run: |
          images=$(jq -R -s -c 'split("\n") | map(select(length > 0))' images.txt)
          echo "matrix={\"image\":$images}" >> $GITHUB_OUTPUT

    outputs:
      image-matrix: ${{ steps.matrix.outputs.matrix }}

  scan-each-image:
    name: Scan each Docker image
    needs: scan-images
    if: needs.scan-images.outputs.image-matrix != ''
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/aquasecurity/trivy:latest
    strategy:
      matrix: ${{fromJson(needs.scan-images.outputs.image-matrix)}}

    steps:

      - name: Sanitize image name for artifact
        id: sanitize-name
        run: |
          img="${{ matrix.image }}"
          file=$(echo "$img" | sed -E 's/[^A-Za-z0-9._-]/_/g')
          echo "Original image name: $img"
          echo "Sanitized for artifact: $file"
          echo "file=$file" >> $GITHUB_OUTPUT

      - name: Scan image
        run: |
          set +e
          mkdir -p failures
          img="${{ matrix.image }}"
          echo "Image to scan: $img"
          # Skip if image is empty
          [ -z "$img" ] && exit 0
          file=$(echo "$img" | sed -E 's/[^A-Za-z0-9._-]/_/g')
          echo "Sanitized filename: $file"
          echo "Sanitized from sanitize-name step: ${{ steps.sanitize-name.outputs.file }}"
          echo "Scanning $img -> ${file}.json" | tee -a trivy.log
          
          # Run trivy scan (using container's pre-installed Trivy)
          trivy image --quiet --format json -o "${file}.json" "$img"
          status=$?
          if [ $status -eq 0 ]; then
            echo "SUCCESS: $img" >> trivy.log
          else
            echo "FAILED: $img" >> trivy.log
            echo "scan failed for $img (exit code $status)" > "failures/${file}.scan_error"
            echo "scan failed for $img (exit code $status)" >> trivy.log
          fi
          set -e

      - name: Upload scan outputs
        uses: actions/upload-artifact@v4
        with:
          name: scan-output-${{ steps.sanitize-name.outputs.file }}
          path: |
            *.json
            trivy.log
            failures/*